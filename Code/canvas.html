<head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec3 varNormal;
varying vec3 eyeVec;
uniform sampler2D paletteMap;

void main(void) {
	vec3 transformedNormal = normalize(varNormal);
	vec3 fragColor;
	if (/*abs(normalize(eyeVec * transformedNormal)).z < 0.5*/!gl_FrontFacing) {
		fragColor = vec3(0.0, 0.0, 0.0);
	} else {
		float lightWeighting = max(transformedNormal.x, 0.0);
		float lightWeighting2 = max(transformedNormal.y, 0.0);
		vec3 lighting = vec3(1.0, 0.4, 0.0) * lightWeighting + vec3(0.0, 0.2, 1.0) * lightWeighting2 + vec3(0.2, 0.2, 0.2);
		fragColor = lighting;
	}
	vec2 paletteMapIndex = vec2(floor(fragColor.r * 255.0) * 16.0 + floor(fragColor.g * 16.0), floor(fragColor.b * 255.0) * 16.0 + floor(mod(fragColor.g * 255.0, 16.0)));
	gl_FragColor = vec4(fragColor, 1.0);//texture2D(paletteMap, paletteMapIndex);
}
</script>

<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec3 vertexNormal;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;
uniform mat3 nMatrix;

varying vec3 varNormal;
varying vec3 eyeVec;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	varNormal = normalize(nMatrix * vertexNormal);
	eyeVec = (mvMatrix * vec4(vertexPosition, 1.0)).xyz;
}
</script>

<script id="srgb-to-cielab" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 rgbConversion;

float linearise(float c) {
	if (c <= 0.04045) {
		return (c / 12.92);
	} else {
		return pow((c + 0.055) / 1.055, 2.4);
	}
}

float labf(float c) {
	if (c > 0.008856) {
		return pow(c, 0.3333);
	} else {
		return 7.787 * c + 0.1379;
	}
}

vec3 srgbToCielab(vec3 srgb) {
	vec3 linearRgb = vec3(linearise(srgb.r), linearise(srgb.g), linearise(srgb.b));
	vec3 ciexyz = rgbConversion * linearRgb;
	float fX = labf(ciexyz.x);
	float fY = labf(ciexyz.y);
	vec3 cielab = vec3(116 * fY - 16, 500 * (fX - fY), 200 * (fY - labf(ciexyz.z)));
	return cielab;
}

void main(void){
	vec3 srgb = vec3(floor(gl_FragCoord.x / 16) / 255.0, (floor(mod(gl_FragCoord.x, 16)) * 16 + floor(mod(gl_FragCoord.y, 16))) / 255.0, floor(gl_FragCoord.y / 16)) / 255.0;
	vec3 cielab = srgbToCielab(srgb);
	gl_FragColor = vec4((cielab.x + 16 / 116), cielab.y / 500, cielab.z / 500, 1.0);
}
</script>

<script id="cielab-to-srgb" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 xyzConversion;

float invlabf(float c) {
	if (c > 0.2069) {
		return c * c * c;
	} else {
		return 0.12842 * (c - 0.1379);
	}
}

float delinearise(float c) {
	if (c <= 0.0031308) {
		return (c * 12.92);
	} else {
		return pow((c * 1.055), 0.41667) - 0.055;
	}
}

vec3 normalisedCielabToSrgb(vec3 normalisedCielab) {
	vec3 ciexyz = vec3(invlabf(normalisedCielab.x), invlabf(normalisedCielab.x + normalisedCielab.y), invlabf(normalisedCielab.x - normalisedCielab.z));
	vec3 linearRgb = xyzConversion * ciexyz;
	vec3 srgb = vec3(delinearise(linearRgb.r), delinearise(linearRgb.g), delinearise(linearRgb.b));
	return srgb;
}

void main(void){
	vec3 cielab = vec3(floor(gl_FragCoord.x / 16) / 255.0, (floor(mod(gl_FragCoord.x, 16)) * 16 + floor(mod(gl_FragCoord.y, 16))) / 255.0, floor(gl_FragCoord.y / 16)) / 255.0;
	vec3 srgb = srgbToCielab(cielab);
	gl_FragColor = vec4(srgb, 1.0);
}
</script>

<script id="basic-fs" type="x-shader/x-fragment">
precision mediump float;

void main(void) {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}
</script>

<script id="basic-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
}
</script>

<script type="text/javascript" src="renderer.js"></script>

</head>

<body onload="start()">
	<canvas id="glcanvas" width="1000" height="800">
		Your browser doesn't support HTML5 Canvas.
	</canvas>
</body>