<head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec3 varNormal;
varying vec3 eyeVec;
varying vec2 varTexCoord;
uniform sampler2D texture;
uniform sampler2D paletteMap;

// will optimise later
uniform sampler2D palette;

void main(void) {
	vec3 transformedNormal = normalize(varNormal);
	vec4 fragColor;
	float lightWeighting = max(transformedNormal.y + transformedNormal.x, 0.0) / 2.0;
	vec3 lighting = vec3(1.0, 1.0, 1.0) * lightWeighting + vec3(0.5, 0.5, 0.5);
	fragColor = texture2D(texture, varTexCoord) * vec4(lighting, 1.0);
	if (abs(dot(normalize(eyeVec), transformedNormal)) < 0.2) {
		fragColor = vec4(fragColor.rgb * (abs(dot(normalize(eyeVec), transformedNormal)) * 5.0), 1.0);
	}
	//vec2 paletteMapIndex = vec2(floor(fragColor.r * 255.0) * 16.0 + floor(fragColor.g * 16.0), floor(fragColor.b * 255.0) * 16.0 + floor(mod(fragColor.g * 255.0, 16.0)));
	float bestDist = 2.0;
	vec4 bestColor;
	vec4 paletteColor;
	int paletteSize = 8; // TODO: pass this value in from main program since WebGL apparently doesn't support GLSL textureSize
	for (int i = 0; i < 16; i++) {
		paletteColor = texture2D(palette, vec2((float(i) + 0.5) / 16.0, 0));
		float dist = distance(paletteColor, fragColor);
		if (dist < bestDist) {
			bestColor = paletteColor;
			bestDist = dist;
		}
	}
	gl_FragColor = bestColor;//texture2D(paletteMap, paletteMapIndex);
}
</script>

<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec3 vertexNormal;
attribute vec2 texCoord;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;
uniform mat3 nMatrix;

varying vec3 varNormal;
varying vec2 varTexCoord;
varying vec3 eyeVec;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	varNormal = normalize(nMatrix * vertexNormal);
	varTexCoord = texCoord;
	eyeVec = (mvMatrix * vec4(vertexPosition, 1.0)).xyz;
}
</script>

<script id="srgb-to-cielab" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 rgbConversion;

float linearise(float c) {
	if (c <= 0.04045) {
		return (c / 12.92);
	} else {
		return pow((c + 0.055) / 1.055, 2.4);
	}
}

float labf(float c) {
	if (c > 0.008856) {
		return pow(c, 0.3333);
	} else {
		return 7.787 * c + 0.1379;
	}
}

vec3 srgbToCielab(vec3 srgb) {
	vec3 linearRgb = vec3(linearise(srgb.r), linearise(srgb.g), linearise(srgb.b));
	vec3 ciexyz = rgbConversion * linearRgb;
	float fX = labf(ciexyz.x);
	float fY = labf(ciexyz.y);
	vec3 cielab = vec3(116 * fY - 16, 500 * (fX - fY), 200 * (fY - labf(ciexyz.z)));
	return cielab;
}

void main(void){
	vec3 srgb = vec3(floor(gl_FragCoord.x / 16) / 255.0, (floor(mod(gl_FragCoord.x, 16)) * 16 + floor(mod(gl_FragCoord.y, 16))) / 255.0, floor(gl_FragCoord.y / 16)) / 255.0;
	vec3 cielab = srgbToCielab(srgb);
	gl_FragColor = vec4((cielab.x + 16 / 116), cielab.y / 500, cielab.z / 500, 1.0);
}
</script>

<script id="cielab-to-srgb" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 xyzConversion;

float invlabf(float c) {
	if (c > 0.2069) {
		return c * c * c;
	} else {
		return 0.12842 * (c - 0.1379);
	}
}

float delinearise(float c) {
	if (c <= 0.0031308) {
		return (c * 12.92);
	} else {
		return pow((c * 1.055), 0.41667) - 0.055;
	}
}

vec3 normalisedCielabToSrgb(vec3 normalisedCielab) {
	vec3 ciexyz = vec3(invlabf(normalisedCielab.x), invlabf(normalisedCielab.x + normalisedCielab.y), invlabf(normalisedCielab.x - normalisedCielab.z));
	vec3 linearRgb = xyzConversion * ciexyz;
	vec3 srgb = vec3(delinearise(linearRgb.r), delinearise(linearRgb.g), delinearise(linearRgb.b));
	return srgb;
}

void main(void){
	vec3 cielab = vec3(floor(gl_FragCoord.x / 16) / 255.0, (floor(mod(gl_FragCoord.x, 16)) * 16 + floor(mod(gl_FragCoord.y, 16))) / 255.0, floor(gl_FragCoord.y / 16)) / 255.0;
	vec3 srgb = srgbToCielab(cielab);
	gl_FragColor = vec4(srgb, 1.0);
}
</script>

<script id="basic-fs" type="x-shader/x-fragment">
precision mediump float;

void main(void) {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}
</script>

<script id="basic-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
}
</script>

<script type="text/javascript" src="renderer.js"></script>

</head>

<body onload="start()">
	<canvas id="glcanvas" width="1000" height="800">
		Your browser doesn't support HTML5 Canvas.
	</canvas>
</body>