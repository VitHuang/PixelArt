<head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="pixel-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec3 varNormal;
varying vec3 eyeVec;
varying vec2 varTexCoord;
uniform sampler2D texture;
uniform sampler2D paletteMap;

// will optimise later
uniform sampler2D palette;

vec4 getMatchingColour(vec4 colour) {
	float bestDist = 2.0;
	vec4 bestColour;
	vec4 paletteColour;
	for (int i = 0; i < 16; i++) {
		paletteColour = texture2D(palette, vec2((float(i) + 0.5) / 16.0, 0));
		float dist = distance(paletteColour, colour);
		if (dist < bestDist) {
			bestColour = paletteColour;
			bestDist = dist;
		}
	}
	return bestColour;
}

void main(void) {
	vec3 transformedNormal = normalize(varNormal);
	vec4 fragColour;
	float lightWeighting = max(transformedNormal.y + transformedNormal.x + transformedNormal.z, 0.0) / 2.0;
	vec3 lighting = vec3(1.0, 1.0, 1.0) * lightWeighting + vec3(0.5, 0.5, 0.5);
	fragColour = texture2D(texture, varTexCoord) * vec4(lighting, 1.0);
	//vec2 paletteMapIndex = vec2(floor(fragColour.r * 255.0) * 16.0 + floor(fragColour.g * 16.0), floor(fragColour.b * 255.0) * 16.0 + floor(mod(fragColour.g * 255.0, 16.0)));
	// TODO: pass this value in from main program since WebGL apparently doesn't support GLSL textureSize
	gl_FragColor = getMatchingColour(fragColour);//texture2D(paletteMap, paletteMapIndex);
}
</script>


<script id="pixel-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec3 vertexNormal;
attribute vec2 texCoord;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;
uniform mat3 nMatrix;

varying vec3 varNormal;
varying vec2 varTexCoord;
varying vec3 eyeVec;

void main(void) {
        gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
        varNormal = normalize(nMatrix * vertexNormal);
        varTexCoord = texCoord;
        eyeVec = (mvMatrix * vec4(vertexPosition, 1.0)).xyz;
}
</script>

<script id="sobel-fs" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D inputImage;
uniform ivec2 imageSize;

varying vec2 varTexCoord;

float unpack(vec4 pack) {
	const vec4 shifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(pack, shifts);
}

float get(vec2 offset) {
	return unpack(texture2D(inputImage, varTexCoord + offset));
}

void main() {
	vec2 pixelOffset = 1.0 / vec2(imageSize);
	float horizontal = 0.09375 * get(vec2(-pixelOffset.x,  -pixelOffset.y)) +
		 0.3125  * get(vec2(0.0,  -pixelOffset.y)) +
		 0.09375 * get(vec2(pixelOffset.x,  -pixelOffset.y)) +
		-0.09375 * get(vec2(-pixelOffset.x,  pixelOffset.y)) +
		-0.3125  * get(vec2(0.0,  pixelOffset.y)) +
		-0.09375 * get(vec2(pixelOffset.x,  pixelOffset.y));
	float vertical = 0.09375 * get(vec2(-pixelOffset.x,  -pixelOffset.y)) +
		 0.3125  * get(vec2(-pixelOffset.x, 0.0)) +
		 0.09375 * get(vec2(-pixelOffset.x,  pixelOffset.y)) +
		-0.09375 * get(vec2(pixelOffset.x,  -pixelOffset.y)) +
		-0.3125  * get(vec2(pixelOffset.x, 0.0)) +
		-0.09375 * get(vec2(pixelOffset.x,  pixelOffset.y));
	horizontal = (1.0 + horizontal) / 2.0;
	vertical = (1.0 + vertical) / 2.0;
	gl_FragColor = vec4(fract(horizontal * 256.0), horizontal, fract(vertical * 256.0), vertical);
}
</script>

<script id="sobel-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec2 texCoord;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;

varying vec2 varTexCoord;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	varTexCoord = texCoord;
}
</script>

<script id="canny-fs" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D depthTexture;
uniform sampler2D normalTexture;
uniform ivec2 textureSize;

varying vec2 varTexCoord;

const float threshold = 0.2;

vec2 gradientOf(vec4 texel) {
	return (vec2(texel.r / 256.0 + texel.g, texel.b / 256.0 + texel.a) * 2.0) - 1.0;
}

bool isOnEdge(sampler2D image) {
	vec2 pixelOffset = 1.0 / vec2(textureSize);
	float left = varTexCoord.x - pixelOffset.x;
	float right = varTexCoord.x + pixelOffset.x;
	float down = varTexCoord.y - pixelOffset.y;
	float up = varTexCoord.y + pixelOffset.y;
	vec4 inTexel = texture2D(image, varTexCoord);
	bool onEdge = false;
	vec2 gradient = gradientOf(inTexel);
	float direction = atan(gradient.y, gradient.x);
	if (direction < 0.0) {
		direction += 3.14159;
	}
	float magnitude = length(gradient);
	if (magnitude >= threshold) {
		if (direction < 0.39270 || direction > 2.74889) {
			// |
			vec4 downTexel = texture2D(image, vec2(varTexCoord.x, down));
			vec4 upTexel = texture2D(image, vec2(varTexCoord.x, up));
			float downMagnitude = length(gradientOf(downTexel));
			float upMagnitude = length(gradientOf(upTexel));
			if (magnitude > downMagnitude && magnitude >= upMagnitude) {
				onEdge = true;
			}
		} else if (direction < 1.17810) {
			// \
			vec4 downLeftTexel = texture2D(image, vec2(left, down));
			vec4 upRightTexel = texture2D(image, vec2(right, up));
			float downLeftMagnitude = length(gradientOf(downLeftTexel));
			float upRightMagnitude = length(gradientOf(upRightTexel));
			if (magnitude > downLeftMagnitude && magnitude >= upRightMagnitude) {
				onEdge = true;
			}
		} else if (direction < 1.96350) {
			// -
			vec4 leftTexel = texture2D(image, vec2(left, varTexCoord.y));
			vec4 rightTexel = texture2D(image, vec2(right, varTexCoord.y));
			float leftMagnitude = length(gradientOf(leftTexel));
			float rightMagnitude = length(gradientOf(rightTexel));
			if (magnitude >= leftMagnitude && magnitude > rightMagnitude) {
				onEdge = true;
			}
		} else {
			// /
			vec4 downRightTexel = texture2D(image, vec2(right, down));
			vec4 upLeftTexel = texture2D(image, vec2(left, up));
			float downRightMagnitude = length(gradientOf(downRightTexel));
			float upLeftMagnitude = length(gradientOf(upLeftTexel));
			if (magnitude > downRightMagnitude && magnitude >= upLeftMagnitude) {
				onEdge = true;
			}
		}
	}
	return onEdge;
}

void main() {
	bool onEdge = isOnEdge(depthTexture) || isOnEdge(normalTexture);
	if (onEdge) {
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	} else {
		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
	}
	//gl_FragColor = vec4(gradientOf(texture2D(depthTexture, varTexCoord)) / 2.0 + 0.5, 0.0, 1.0);
}
</script>

<script id="canny-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec2 texCoord;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;

varying vec2 varTexCoord;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	varTexCoord = texCoord;
}
</script>

<script id="normal-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec3 varNormal;
varying vec3 eyeVec;

vec4 pack(float x) {
	const vec4 shifts = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 pack = fract(x * shifts);
	pack -= pack.xxyz * mask;
	return pack;
}

void main(void) {
	float angle = abs(dot(normalize(eyeVec), normalize(varNormal)));
	gl_FragColor = pack(angle);
}
</script>

<script id="normal-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec3 vertexNormal;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;
uniform mat3 nMatrix;

varying vec3 varNormal;
varying vec3 eyeVec;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	varNormal = normalize(nMatrix * vertexNormal);
	eyeVec = (mvMatrix * vec4(vertexPosition, 1.0)).xyz;
}
</script>

<script id="depth-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec3 varNormal;

varying vec4 fragPosition;

vec4 pack(float x) {
	const vec4 shifts = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 pack = fract(x * shifts);
	pack -= pack.xxyz * mask;
	return pack;
}

void main(void) {
	float depth = (fragPosition.z / fragPosition.w + 1.0) / 2.0;
	gl_FragColor = pack(depth);
}
</script>

<script id="depth-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec3 vertexNormal;
varying vec3 varNormal;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;
uniform mat3 nMatrix;

varying vec4 fragPosition;

void main(void) {
	vec4 position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	fragPosition = position;
	gl_Position = position;
	varNormal = normalize(nMatrix * vertexNormal);
}
</script>

<script id="srgb-to-cielab" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 rgbConversion;

float linearise(float c) {
	if (c <= 0.04045) {
		return (c / 12.92);
	} else {
		return pow((c + 0.055) / 1.055, 2.4);
	}
}

float labf(float c) {
	if (c > 0.008856) {
		return pow(c, 0.3333);
	} else {
		return 7.787 * c + 0.1379;
	}
}

vec3 srgbToCielab(vec3 srgb) {
	vec3 linearRgb = vec3(linearise(srgb.r), linearise(srgb.g), linearise(srgb.b));
	vec3 ciexyz = rgbConversion * linearRgb;
	float fX = labf(ciexyz.x);
	float fY = labf(ciexyz.y);
	vec3 cielab = vec3(116 * fY - 16, 500 * (fX - fY), 200 * (fY - labf(ciexyz.z)));
	return cielab;
}

void main(void){
	vec3 srgb = vec3(floor(gl_FragCoord.x / 16) / 255.0, (floor(mod(gl_FragCoord.x, 16)) * 16 + floor(mod(gl_FragCoord.y, 16))) / 255.0, floor(gl_FragCoord.y / 16)) / 255.0;
	vec3 cielab = srgbToCielab(srgb);
	gl_FragColor = vec4((cielab.x + 16 / 116), cielab.y / 500, cielab.z / 500, 1.0);
}
</script>

<script id="cielab-to-srgb" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 xyzConversion;

float invlabf(float c) {
	if (c > 0.2069) {
		return c * c * c;
	} else {
		return 0.12842 * (c - 0.1379);
	}
}

float delinearise(float c) {
	if (c <= 0.0031308) {
		return (c * 12.92);
	} else {
		return pow((c * 1.055), 0.41667) - 0.055;
	}
}

vec3 normalisedCielabToSrgb(vec3 normalisedCielab) {
	vec3 ciexyz = vec3(invlabf(normalisedCielab.x), invlabf(normalisedCielab.x + normalisedCielab.y), invlabf(normalisedCielab.x - normalisedCielab.z));
	vec3 linearRgb = xyzConversion * ciexyz;
	vec3 srgb = vec3(delinearise(linearRgb.r), delinearise(linearRgb.g), delinearise(linearRgb.b));
	return srgb;
}

void main(void){
	vec3 cielab = vec3(floor(gl_FragCoord.x / 16) / 255.0, (floor(mod(gl_FragCoord.x, 16)) * 16 + floor(mod(gl_FragCoord.y, 16))) / 255.0, floor(gl_FragCoord.y / 16)) / 255.0;
	vec3 srgb = srgbToCielab(cielab);
	gl_FragColor = vec4(srgb, 1.0);
}
</script>

<script id="texture-fs" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D texture;

varying vec2 varTexCoord;

void main(void) {
	gl_FragColor = texture2D(texture, varTexCoord);
}
</script>

<script id="texture-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;
attribute vec2 texCoord;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;

varying vec2 varTexCoord;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
	varTexCoord = texCoord;
}
</script>

<script id="basic-fs" type="x-shader/x-fragment">
precision mediump float;

void main(void) {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}
</script>

<script id="basic-vs" type="x-shader/x-vertex">
attribute vec3 vertexPosition;

uniform mat4 pMatrix;
uniform mat4 mvMatrix;

void main(void) {
	gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);
}
</script>

<script type="text/javascript" src="renderer.js"></script>

</head>

<body onload="start()">
	<canvas id="glcanvas" width="1024" height="1024">
		Your browser doesn't support HTML5 Canvas.
	</canvas>
</body>